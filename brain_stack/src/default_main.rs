// Comments taken from:
//https://ece-196.github.io/docs/assignments/spinning-and-blinking/rust/blinking/

#![no_std] /*
    indicates that our program will not have acces to the Rust standard library.
    This is because embedded systems are resource constrained environments with no operating system,
    so simple things like allocation are suddenly not so simple. 
    This directive informs the Rust compiler that the standard library is unavailable, 
    which permits us to target the microcontroller.
 */
#![no_main] /*
     indicates that the entry-point to our program is non-trivial. 
     The Rust compiler typically expects the entry-point to be defined as a top-level function named main, 
     however as we will soon see, the entry-point will not be defined by us, 
     and will be generated by Embassy to begin async operation and start the executor.
*/

use embassy_executor::Spawner;
use embassy_time::Timer;
use esp_backtrace as _;
use esp_hal::{
    gpio::{Io, Level, Output},
    timer::timg::TimerGroup,
};
use esp_println::println; /*
    This looks like a lot, but these are just crates we are importing to use in our program. 
    We will see exactly which crates we use and why as we explore the rest of this file.
*/

#[esp_hal_embassy::main]
async fn main(_spawner: Spawner) { /*
    Next you will see this ^ function.
    This function is hosted by Embassy, and is what we will use to kick off our firmware.
    You may notice it is async! This means the executor has already started, 
    and we can utilize all of Rust’s concurrency features right away!
    
    #[main] is an attribute macro from Embassy that transforms our async function 
    definition into the proper structure for starting the executor and configuring the CPU/static memory.
    
    This function provides us with a single parameter of type Spawner. 
    This type allows us to spawn tasks, 
    which we don’t need for a simple blink program so we marked the variable as unused with the leading underscore.
    Now let’s look at what exactly we do in this function to configure our microcontroller.
*/

// enable logging via the ESP32s JTAG5 controller:
    esp_println::logger::init_logger_from_env();
    
// we take ownership of all peripherals. This operation can only be done once, per RAII, we may only have one binding for one resource:
    let peripherals = esp_hal::init(esp_hal::Config::default());

// initialize the 0th timer group (which we can use to provide Embassy with a means for keeping time):
    let timg0 = TimerGroup::new(peripherals.TIMG0);

// Embassy needs a impl TimerCollection (some timer that implements the trait TimerCollection) to provide monotonics6:
    esp_hal_embassy::init(timg0.timer0);
    
/* 
    We understand that this may be uncharted territory for many of you. 
    We implore you to do your own research, read about Rust, and mess with it on your own. 
    The foundational principles we are leveraging are not easy to grasp initially, 
    so know that you are not alone if you are struggling. The tutors are here to help, 
    and don’t forget about the resources page.
*/

// We create a binding to the GPIO and IO_MUX (multiplexer for the GPIO) peripherals to gain control of IO.
    let io = Io::new(peripherals.GPIO, peripherals.IO_MUX);

// Then we configure pin 17 to be an output pin with a default level of low.
    let mut led = Output::new(io.pins.gpio17, Level::Low);

// And finally, in an infinite loop, we print Hello, World!, toggle the LED, and wait for 1 second!
    loop {
        println!("Hello, World!");
        led.toggle();
        Timer::after_millis(1_000).await;
    } /*
        You may notice as part of that “waiting”, there is a trailing .await. 
        In async contexts, this indicates yielding control back to the executor. 
        If we had other tasks waiting to do work, they would get to while this task waits. 
        This simple handoff of execution is what makes async such a powerful language feature.
    */
}
